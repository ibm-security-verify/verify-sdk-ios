//
// Copyright contributors to the IBM Verify Digital Credentials SDK for iOS project
//

import Foundation
import Core

// MARK: Proof Request

/// Describes data that could be used to fill out a requested attribute in a proof request.  It's data describes information from a single credential in the agent's wallet.
public struct ProofRequest {
    /// The name of the proof request. For example "proof_of_employment".
    public let name: String?
    
    /// The version of the proof. For exmaple. "1.0", "1.0.0", etc.
    public let version: String?

    /// All requested attributes elements must contain either a name field, whose value is a string or a names field, whose value is an array of strings. If the names field is used with a restrictions field, the value of all attribute names MUST come from a single credential.
    public let requestedAttributes: [String: AnyDecodable]?
    
    /// Proof pertaining to an attribute without actually knowing the value of the attribute.
    public let requestedPredicate: Predicate?
    
    /// Match credentials with filter.
    public let credentialFilters: [CredentialFilter]?
    
    /// General properties used to sort or decorate the object.
    public let properties: [String: AnyCodable]?
    
    /// Verifier proof presentation defination in JSON-LD credential format.
    public let jsonId: PresentationRequest?
    
    /// Verifier proof presentation defination in JSON-LD credential format.
    public let mdoc: PresentationRequest?
    
    /// Verifier proof presentation defination in BBS signature scheme.
    public let bbs: PresentationRequest?
    
    /// A string, a decimal, 80-bit number generated by the verifier that should be unique per presentation request.
    ///
    /// The nonce is included in the request to prevent replay attacks through its use in creating and verifying the presentation.
    // let nonce: String
}

extension ProofRequest {
    // MARK: Predicate

    /// Request a proof using a predicate to filter.
    public struct Predicate: Decodable {
        /// The name of an attribute from a source credential to use in the predicate expression.
        public let name: String
        
        /// The ``PredicateType``
        public let type: PredicateType
        
        /// The vailue associated with the name and predicate type.
        public let value: String
        
        // MARK: Predicate Enum Types

        /// Defines the predicate operator to filter records.
        public enum PredicateType: String, Decodable {
            /// Filter the value to be equal to the specified value.
            case equal = "="
            
            /// Filter the value to be not equal to the specified value.
            case notEqual = "!="
            
            /// Filter the value to be greater than the specified value.
            case greaterThan = ">"
            
            /// Filter the value to be greater or equal to the specified value.
            case greaterThanOrEqual = ">="
            
            /// Filter the value to be less than the specified value.
            case lessThan = "<"
            
            /// Filter the value to be less or equal to the specified value.
            case lessThanOrEqual = "<="
        }
    
        // MARK: Enums

        /// The root level JSON structure for decoding.
        private enum CodingKeys: String, CodingKey {
            case name
            case type = "p_type"
            case value = "p_value"
        }
        
        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.name = try container.decode(String.self, forKey: .name)
            self.type = try container.decode(PredicateType.self, forKey: .type)
            self.value = try container.decode(String.self, forKey: .value)
        }
    }
}

extension ProofRequest {
    // MARK: Credential Filter

    /// Match credentials with filter. The rule is matched if a credential contains the attribute `attributeName` and the value matches any of the regular expressions in the `attributeValues` array.
    public struct CredentialFilter: Decodable {
        /// Name of attribute.
        public let attributeName: String
        
        /// An array of reqular expression strings)  For example `["Math *"]`
        public let attributeValues: [String]
        
        /// A specific proof request referent. This field references the original proof request.  For example "Study Class Referent".
        public let proofRequestReferent: String?
        
        /// If a rule matches, the exclude flag determins whether to include or exclude the credential from the holder's view.
        /// Default is **false**
        public let exclude: Bool
        
        // MARK: Enums
        
        /// The root level JSON structure for decoding.
        private enum CodingKeys: String, CodingKey {
            case attributeName = "attr_name"
            case attributeValues = "attr_values"
            case proofRequestReferent = "proof_request_referent"
            case exclude
        }
        
        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.attributeName = try container.decode(String.self, forKey: .attributeName)
            self.attributeValues = try container.decode([String].self, forKey: .attributeValues)
            self.proofRequestReferent = try container.decodeIfPresent(String.self, forKey: .proofRequestReferent)
            self.exclude = try container.decodeIfPresent(Bool.self, forKey: .exclude) ?? false
        }
    }
}

extension ProofRequest {
    // MARK: Presentation Request
    
    /// A presentation request is any transport mechanism used to send a ``PresentationDefinition`` from a verifier to a holder.
    public struct PresentationRequest: Decodable {
        /// Presentation Definitions are objects that articulate what proofs a verifier requires. These help the verifier to decide how or whether to interact with a holder.
        public let presentationDefination: PresentationDefinition
        
        /// A container of additional parameters required for the holder to fulfill the verifier's request.
        public let options: Options?
        
        // MARK: Enums
        
        /// The root level JSON structure for decoding.
        private enum CodingKeys: String, CodingKey {
            case presentationDefination = "presentation_definition"
            case options
        }
        
        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.presentationDefination = try container.decode(PresentationDefinition.self, forKey: .presentationDefination)
            self.options = try container.decodeIfPresent(Options.self, forKey: .options)
        }
    }
}

extension ProofRequest.PresentationRequest {
    // MARK: Presentation Defination
    
    /// Presentation Definitions are objects that articulate what proofs a verifier requires. These help the verifier to decide how or whether to interact with a holder.
    ///
    /// Presentation Definitions are composed of inputs, which describe the forms and details of the proofs they require, and optional sets of selection rules, to allow Holders flexibility in cases where many different types of proofs may satisfy an input requirement.
    public struct PresentationDefinition: Identifiable, Decodable {
        /// A unique ID for the desired context.
        public let id: String
        
        /// A human-friendly string intended to constitute a distinctive designation of the presentation definition.
        public let name: String?
        
        /// Describes the purpose for which the presentation definition's inputs are being used for.
        public let purpose: String?
        
        /// An object consisting of keyed arrays. For example, `jwt`,`jwt_vc`,` jwt_vp`, etc.
        ///
        /// The format identifies supported profiles the verifier can process the claims of the holder.
        public let format: Format
        
        /// Describes what combinations of inputs must be submitted to comply with its requirements for proceeding in a verification flow.
        public let submissionRequirement: [SubmissionRequirement]?
        
        public let inputDescriptors: [InputDescriptor]?
        
        // MARK: Enums
        
        /// The root level JSON structure for decoding.
        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case purpose
            case format
            case submissionRequirement = "submission_requirements"
            case inputDescriptor = "input_descriptors"
        }
        
        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.id = try container.decode(String.self, forKey: .id)
            self.name = try container.decodeIfPresent(String.self, forKey: .name)
            self.purpose = try container.decodeIfPresent(String.self, forKey: .purpose)
            self.format = try container.decode(Format.self, forKey: .format)
            self.submissionRequirement = try container.decodeIfPresent([SubmissionRequirement].self, forKey: .submissionRequirement)
            self.inputDescriptors = try container.decodeIfPresent([InputDescriptor].self, forKey: .inputDescriptor)
        }
    }
    
    // MARK: Presentation Options
    
    /// A container of additional parameters required for the holder to fulfill the verifier's request.
    public struct Options: Decodable {
        /// Random seed provided by the verifier.
        public let challenge: String?
        
        /// The operational domain of the requested proof.
        public let domain: String?
    }
}

extension ProofRequest.PresentationRequest.PresentationDefinition {
    /// A set of possible envelopes and signing mechanisms for claims.
    public enum Format: Decodable {
        /// The JSON Web Token (JWT) format.
        /// - Parameters:
        ///   - alg: A list of algorithm references from the JW* family of tokens  that may be supported within the format.
        case jwt(alg: [String])
        
        /// The JSON Web Token (JWT) for the verifable credential W3C data-model specification.
        /// - Parameters:
        ///   - alg: A list of algorithm references from the JW* family of tokens  that may be supported within the format.
        case jwtVc(alg: [String])
        
        /// The JSON Web Token (JWT) for the verifable credential W3C data-model specification in JSON format.
        /// - Parameters:
        ///   - alg: A list of algorithm references from the JW* family of tokens  that may be supported within the format.
        case jwtVcJson(alg: [String])
        
        /// The JSON Web Token (JWT) for verifable proof format.
        /// - Parameters:
        ///   - alg: A list of algorithm references from the JW* family of tokens  that may be supported within the format.
        case jwtVp(alg: [String])
        
        /// The JSON Web Token (JWT) for verifable proof in JSON format.
        /// - Parameters:
        ///   - alg: A list of algorithm references from the JW* family of tokens  that may be supported within the format.
        case jwtVpJson(alg: [String])
        
        /// Linked-Data Proof (LDP) that will be submitted as an object.
        /// - Parameters:
        ///   - proofType: A list of Linked-Data integrity proof types that may be supported within the format.
        case ldp(proofType: [String])
        
        /// Verifiable credential signed with Linked Data Proof (LDP) formats.
        /// - Parameters:
        ///   - proofType: A list of Linked-Data integrity proof types that may be supported within the verifable credential W3C data-model specification.
        case ldpVc(proofType: [String])
        
        /// Verifiable presentations signed with Linked Data Proof (LDP) formats.
        /// - Parameters:
        ///   - proofType: A list of Linked-Data integrity proof types that may be supported within the format.
        case ldpVp(proofType: [String])
        
        /// MDOC verifiable presentations signed format.
        /// - Parameters:
        //  - alg: A list of algorithm references from the JW* family of tokens  that may be supported within the format.
        case mdoc(alg: [String])
    }
    
    /// Submission Requirements are objects that define what combinations of inputs must be submitted to comply with the requirements a verifier has for proceeding in a flow (e.g. credential issuance, allowing entry, accepting an application).
    public struct SubmissionRequirement: Decodable {
        // MARK: Internal
        
        /// Describe the specific combinatorial rules that must be applied to submit a particular subset of requested inputs.
        public enum RuleType: String, Codable {
            /// The behavior requires the `from` or `fromNested` properties be submitted to the verifier.
            case all
            
            /// The behavior requires the `from` or `fromNested` properties be submitted to the verifier.  The rule may contain `count`, `min` and ``max`` properties.
            case pick
        }
        
        /// Used by a consuming user agent to display the general name of the requirement set to a user.
        public let name: String?
        
        /// The purpose for which the submission is being requested.
        public let purpose: String?
        
        /// Describes the rule within a submission requirement when processing inputs.
        public let rule: RuleType
        
        /// Indicates the number of ``InputDescriptor`` or submission requirements to be submitted.
        public let count: Int?
        
        /// Indicates the minimum number of ``InputDescriptor`` or submission requirements to be submitted. When specified, the value must be greater than or equal to zero.
        public let min: Int?
        
        /// Indicates the maximum number of ``InputDescriptor`` or submission requirements to be submitted.  When specified, the value must be  greater than zero and, if also present, greater than the value of the `min` property.
        public let max: Int?
        
        /// All ``InputDescriptor`` matching the `group` string of the `from` value that is submitted to the verifier.
        public let from: String?
        
        /// All submission requirement specified in the `fromNested` array must be satisfied by the inputs submitted to the verifier.
        public let fromNested: [SubmissionRequirement]?
        
        // MARK: Enums
        
        /// The root level JSON structure for decoding.
        private enum CodingKeys: String, CodingKey {
            case name
            case purpose
            case rule
            case count
            case min
            case max
            case from
            case fromNested = "from_nested"
        }
        
        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.name = try container.decodeIfPresent(String.self, forKey: .name)
            self.purpose = try container.decodeIfPresent(String.self, forKey: .purpose)
            self.rule = try container.decode(RuleType.self, forKey: .rule)
            self.count = try container.decodeIfPresent(Int.self, forKey: .count)
            self.min = try container.decodeIfPresent(Int.self, forKey: .min)
            self.max = try container.decodeIfPresent(Int.self, forKey: .max)
            self.from = try container.decodeIfPresent(String.self, forKey: .from)
            self.fromNested = try container.decodeIfPresent([SubmissionRequirement].self, forKey: .fromNested)
        }
    }
    
    // MARK: Input Descriptor
    
    /// Used by a Verifier to describe the information required of a Holder before an interaction can proceed.
    public struct InputDescriptor: Identifiable {
        // MARK: Internal

        /// URIs for claim schema.
        public struct Schema: Decodable {
            /// URI for claim.
            public let uri: URL
            
            /// Indicates that the given schema object is required to be the schema of the inputs used to fulfill the given ``SubmissionRequirement``.
            public let required: Bool
        }
        
        /// Indicates that the processing entity must limit submitted fields to those listed in the fields array (if present).
        public struct Constraints: Decodable {
            // MARK: Internal
            
            /// Optional parameters for `limitDisclosure` and `subjectIsIssuer` properities that determine if entity processing should include prrofs.
            public enum OptionalityType: String, Decodable {
                /// This indicates that the processing entity must include proof that the Subject of each attribute identified by a value in the `fieldId` array is the same as the entity submitting the response.
                case required
                
                /// Indicates that it is recomended that the processing entity include proof that the Subject of each attribute identified by a value in the `fieldId` array is the same as the entity submitting the response.
                case preferred
            }
            
            /// The credential status.
            public enum StatusType: Decodable, Equatable {
                /// A credential is active if it is not revoked, expired, suspended, or in any type of deactivated state
                /// - Parameters:
                ///   - directive:The credential of the specified status.
                ///
                /// Possible values are:
                ///  - `required`
                ///  - `allowed`
                ///  - `disallowed`
                case active(directive: String)
                
                ///A credential is suspended if the Issuer has published an explicit signal that the credential is in an inactive state and should not currently be relied upon, but may become active again in the future.
                /// - Parameters:
                ///   - directive:The credential of the specified status.
                ///
                /// Possible values are:
                ///  - `required`
                ///  - `allowed`
                ///  - `disallowed`
                case suspended(directtive: String)
                
                ///A credential is revoked if the Issuer has published an explicit signal that the credential in question should not be relied upon going forward as an accurate reflection of the Issuer’s statements about the Subject within the scope of the credential.
                /// - Parameters:
                ///   - directive:The credential of the specified status.
                ///
                /// Possible values are:
                ///  - `required`
                ///  - `allowed`
                ///  - `disallowed`
                case revoked(directive: String)
            }
            
            /// Structure that submit proofs to verifiers to satisfy the requirements described in a presentation definition.
            public struct HolderSubject: Decodable {
                /// An array of strings, with each string matching the string value from a field object’s id property.
                public let fieldId: [String]
                
                /// The entity processing requirement.
                public let directive: OptionalityType
                
                // MARK: Enums
                
                /// The root level JSON structure for decoding.
                private enum CodingKeys: String, CodingKey {
                    case fieldId = "field_id"
                    case directive
                }
            }
            
            /// Structure that submit proofs to verifiers to satisfy the requirements described in a presentation definition.
            public struct Field: Decodable {
                // MARK: Internal
                
                /// A structure used to filter against the values returned from evaluation of the `path` array.
                public struct Filter: Decodable {
                    /// The `const` descriptor to request a proof where an attribute is equal to.
                    public let const: AnyDecodable?
                    
                    /// The ``enum`` descriptor to request a proof where an attribute contains an array of values.
                    public let `enum`: [AnyDecodable]?
                    
                    /// The `exclusiveMinimum` descriptor to request a proof where an attribute is greater than.
                    public let exclusiveMinimum: AnyDecodable?
                    
                    /// The `exclusiveMaximum` descriptor to request a proof where an attribute is less than.
                    public let exclusiveMaximum: AnyDecodable?
                    
                    /// The `minimum` descriptor to request a proof where an attribute is greater than or equal to.
                    public let minimum: AnyDecodable?
                    
                    /// The `maximum` descriptor to request a proof where an attribute is less than or equal to.
                    public let maximum: AnyDecodable?
                    
                    /// The `const` descriptor to request a proof where an attribute is not equal to.
                    public let not: AnyDecodable?
                    
                    /// The type
                    public let type: String
                    
                    // MARK: Enums
                    
                    /// The root level JSON structure for decoding.
                    private enum CodingKeys: String, CodingKey {
                        case const
                        case `enum`
                        case exclusiveMinimum
                        case exclusiveMaximum
                        case minimum
                        case maximum
                        case not
                        case type
                    }
                    
                    public init(from decoder: any Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)
                        self.const = try container.decodeIfPresent(AnyDecodable.self, forKey: .const)
                        self.enum = try container.decodeIfPresent([AnyDecodable].self, forKey: .enum)
                        self.exclusiveMinimum = try container.decodeIfPresent(AnyDecodable.self, forKey: .exclusiveMinimum)
                        self.exclusiveMaximum = try container.decodeIfPresent(AnyDecodable.self, forKey: .exclusiveMaximum)
                        self.minimum = try container.decodeIfPresent(AnyDecodable.self, forKey: .minimum)
                        self.maximum = try container.decodeIfPresent(AnyDecodable.self, forKey: .maximum)
                        self.not = try container.decodeIfPresent(AnyDecodable.self, forKey: .not)
                        self.type = try container.decode(String.self, forKey: .type)
                    }
                }
                
                /// A unique identifier property.
                public let id: String?
                
                /// An array of strings representing a JSON path expression.
                public let path: [String]
                
                /// Describes the purpose for which the field is being requested.
                public let purpose: String?
                
                /// A descriptor used to filter against the values returned from evaluation of the `path` array.
                public let filter: Filter?
                
                /// A predicate restricted according to the desired `filter` property.
                public let predicate: OptionalityType?
            }
            
            /// A response that contains more than the data described in the fields array.
            public let limitDisclosure: OptionalityType?
            
            /// The status of a verification.
            public let statuses: StatusType?
            
            /// An array of ``Field`` that are evaluated against the input descriptor.
            public let fields: [Field]?
            
            /// Used by a Verifier to require that certain inputs be self attested. For example, a college application presentation definition might contain an input descriptor for an essay submission. In this case, the verifier would be able to require that the essay be provided by the same subject as any other claims in the presented application.
            public let subjectIsIssuer: OptionalityType?
            
            /// Used by a verifier to require that certain inputs be provided by a certain subject.  For example, an identity verification presentation definition might contain an input descriptor for a birthdate from a birth certificate. Using `isHolder`, the verifier would be able to require that the holder of the birth certificate claim is the same as the subject of the birthdate attribute.
            public let isHolder: [HolderSubject]?
            
            /// Used by a Verifier to require that certain inputs be self attested. For example, a college application presentation definition might contain an input descriptor for an essay submission. In this case, the verifier would be able to require that the essay be provided by the same subject as any other claims in the presented application.
            public let sameSubject: [HolderSubject]?
            
            // MARK: Enums
            
            /// The root level JSON structure for decoding.
            private enum CodingKeys: String, CodingKey {
                case limitDisclosure = "limit_disclosure"
                case statuses
                case fields
                case subjectIsIssuer = "subject_is_issuer"
                case isHolder = "is_holder"
                case sameSubject = "same_subject"
            }
        }
        
        /// A unique ID for the input descriptor.
        public let id: String
        
        /// A human-friendly name that describes what the target schema represents.
        public let name: String?
        
        /// Describes the purpose for which the Claim's data is being requested.
        public let purpose: String?
        
        /// Matches one of the grouping strings listed in the ``SubmissionRequirement/from-property`` values of a ``SubmissionRequirement`` object.
        public let group: [String]?
        
        /// An array of URIs for claim schema’s.
        public let schema: [Schema]?
        
        public let constraints: Constraints?
    }
}

extension ProofRequest.PresentationRequest.PresentationDefinition.InputDescriptor: Decodable {
    // MARK: Enums
    
    /// The root level JSON structure for decoding.
    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case purpose
        case group
        case schema
        case constraints
    }
    
    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(String.self, forKey: .id)
        self.name = try container.decodeIfPresent(String.self, forKey: .name)
        self.purpose = try container.decodeIfPresent(String.self, forKey: .purpose)
        self.group = try container.decodeIfPresent([String].self, forKey: .group)
        self.schema = try container.decodeIfPresent([Schema].self, forKey: .schema)
        self.constraints = try container.decodeIfPresent(Constraints.self, forKey: .constraints)
    }
}

extension ProofRequest.PresentationRequest.PresentationDefinition.Format {
    enum CodingKeys: String, CodingKey {
        case jwt
        case jwtVc = "jwt_vc"
        case jwtVcJson = "jwt_vc_json"
        case jwtVp = "jwt_vp"
        case jwtVpJson = "jwt_vp_json"
        case ldp
        case ldpVc = "ldp_vc"
        case ldpVp = "ldp_vp"
        case mdoc = "mso_mdoc"
    }
    
    enum LdpCodingKeys: String, CodingKey {
        case proofType = "proof_type"
    }
    
    enum LdpVpCodingKeys: String, CodingKey {
        case proofType = "proof_type"
    }
    
    enum LdpVcCodingKeys: String, CodingKey {
        case proofType = "proof_type"
    }
}

extension ProofRequest: Decodable {
    // MARK: Enums

    /// The root level JSON structure for decoding.
    private enum CodingKeys: String, CodingKey {
        case name
        case version
        case requestedAttribtes = "requested_attributes"
        case requestedPredicate = "requested_predicates"
        case properties
        case credentialFilters = "cred_filter"
        case jsonld
        case mdoc = "mso_mdoc"
        case bbs
    }
    
    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decodeIfPresent(String.self, forKey: .name)
        self.version = try container.decodeIfPresent(String.self, forKey: .version)
        
        // Requested attributes
        self.requestedAttributes = try container.decodeIfPresent([String: AnyDecodable].self, forKey: .requestedAttribtes)
                
        // Requested predicate, we handle the error when the payload element exists, but not no data.
        do {
            self.requestedPredicate = try container.decodeIfPresent(Predicate.self, forKey: .requestedPredicate)
        }
        catch {
            self.requestedPredicate = nil
        }
        
        // Properties
        self.properties = try container.decodeIfPresent([String: AnyCodable].self, forKey: .properties)
        
        // Credential filters, we handle the error when the payload element exists, but not no data.
        self.credentialFilters = try container.decodeIfPresent([CredentialFilter].self, forKey: .credentialFilters)
        
        // Signature schemes
        self.jsonId = try container.decodeIfPresent(PresentationRequest.self, forKey: .jsonld)
        self.mdoc = try container.decodeIfPresent(PresentationRequest.self, forKey: .mdoc)
        self.bbs = try container.decodeIfPresent(PresentationRequest.self, forKey: .bbs)
    }
}
