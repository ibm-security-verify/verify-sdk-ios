//
// Copyright contributors to the IBM Verify FIDO2 SDK for iOS project
//

import Foundation
import Security
import LocalAuthentication
import CryptoKit
import os.log

/// This class provides helper methods to generate, query and delete private keys.  In addition, the class provides the ability to sign data and export the public key.
internal struct SecKeyStore {
    // The access control to geneate and sign with the private key.
    private let accessControl = SecAccessControlCreateWithFlags(nil,
                                                                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,
                                                                [.privateKeyUsage, .userPresence],
                                                                nil)!
    
    /// Generates the private and public key for future signing operations.
    func generate(context: LAContext) throws -> SecureEnclave.P256.Signing.PrivateKey? {
        var key: SecureEnclave.P256.Signing.PrivateKey? = nil
        os_log("Generating private key in SecureEnclave.", log: .crypto, type: .info)
        key = try? SecureEnclave.P256.Signing.PrivateKey(compactRepresentable: true, accessControl: self.accessControl, authenticationContext: context)
        os_log("Private key created successfully.", log: .crypto, type: .info)
        return key
    }
    
    
    /// Stores a CryptoKit key in the keychain as a SecKey instance.
    /// - Parameters:
    ///   - account: The account to store the key under in the key store.
    ///   - key: The key generated by the Secure Enclave in it raw representation.
    func add<T: SecKeyConvertible>(_ account: String, key: T) throws {
        let query = [kSecClass: kSecClassGenericPassword,
                     kSecAttrAccount: account,
                     kSecValueData as String: key.rawRepresentation] as CFDictionary
        
        // Add the key data.
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            os_log("Unable to store item %{public}@.", log: .crypto, type: .debug, status.message)
            throw KeyStoreError("Unable to store item. \(status.message)")
        }
        
        os_log("Key %{public}@ added to Keychain.", log: .crypto, type: .info, account)
    }
    
    /// Reads a CryptoKit key from the keychain as the raw representation of the key.
    /// - Parameters:
    ///   - account: The account assigned to the key.
    ///   - context: The Local Authentication context to associate with the key. Default is nil.
    /// - Returns: The `SecureEnclave.P256.Signing.PrivateKey` if found, otherwise `nil`.
    func read(_ account: String, context: LAContext? = nil) -> SecureEnclave.P256.Signing.PrivateKey? {
        // Seek a generic password with the given account.
        let query = [kSecClass: kSecClassGenericPassword,
                     kSecAttrAccount: account,
                     kSecUseDataProtectionKeychain: true,
                     kSecReturnData: true] as CFDictionary
        
        // Find and cast the result as data.
        var item: CFTypeRef?
        switch SecItemCopyMatching(query as CFDictionary, &item) {
        case errSecSuccess:
            os_log("Key found with name %{public}@.", log: .crypto, type: .info, account)
            return try? SecureEnclave.P256.Signing.PrivateKey(dataRepresentation: item as! Data, authenticationContext: context)  // Convert back to a key.
        case errSecItemNotFound:
            os_log("No key found with name %{public}@.", log: .crypto, type: .info, account)
            return nil
        case let status:
            os_log("Keychain read failed %{public}@.", log: .crypto, type: .debug, status.message)
            return nil
        }
    }
        
    /// Removes any existing key with the given account.
    /// - Parameter account: The account assigned to the key.
    func delete(_ account: String) throws {
        let query = [kSecClass: kSecClassGenericPassword,
                     kSecUseDataProtectionKeychain: true,
                     kSecAttrAccount: account] as CFDictionary
        
        switch SecItemDelete(query) {
        case errSecItemNotFound, errSecSuccess:
            os_log("Key found with name %{public}@ deleted.", log: .crypto, type: .info, account)
            break // Okay to ignore
        case let status:
            os_log("Unexpected deletion error %{public}@.", log: .crypto, type: .debug, status.message)
            throw KeyStoreError("Unexpected deletion error. \(status.message)")
        }
    }
}

/// The error description for a failed `SecKey` operations.
struct KeyStoreError: Error, LocalizedError, CustomStringConvertible {
    private var _description: String
    
    /// Initiatizes a new `KeyStoreError` instance.
    /// - Parameter description: The error messge accompanying the error.
    init(_ description: String) {
        self._description = description
    }
    
    /// The error description accompanying the error.
    public var description: String {
        return _description
    }
    
    public var localizedDescription: String {
        return NSLocalizedString(_description, comment: "")
    }
}

extension OSStatus {
    /// A human readable message for the status.
    var message: String {
        return (SecCopyErrorMessageString(self, nil) as String?) ?? String(self)
    }
}
