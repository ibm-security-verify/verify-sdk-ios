//
// Copyright contributors to the IBM Security Verify MFA SDK for iOS project
//

import Foundation
import Authentication
import Core

/// The `CloudAuthenticatorService` enables authenticators to perform transaction, login and token refresh operations.
public actor CloudAuthenticatorService: MFAServiceDescriptor {
    /// The enumerated type to apply to retrieving cloud transaction data.
    internal enum TransactionFilter: String {
        /// Includes id, creationTime, transactionData and authenticationMethods when the transaction is pending.
        ///
        /// Sorted by creation time.
        case nextPending = "?filter=id,creationTime,transactionData,authenticationMethods&search=state=%22PENDING%22&sort=-creationTime"

        /// Includes id, creationTime, transactionData and authenticationMethods when the transaction pending.
        ///
        /// Search is by id={transactionID}.
        case pendingByIdentifier = "?filter=id,creationTime,transactionData,authenticationMethods&search=state=\u{22}PENDING\u{22}&id=\u{22}%@\u{22}"
    }
    
    public private(set) var accessToken: String
    public private(set) var currentPendingTransaction: PendingTransactionInfo?
    public var publicKeyCertificate: String? = nil
    nonisolated public let refreshUri: URL
    nonisolated public let transactionUri: URL
    
    /// An object that coordinates a group of related, network data transfer tasks.
    private let urlSession: URLSession
    
    /// A unique identifier to link a mobile application to the cloud service.
    private let authenticatorId: String
    
    /// Creates the service with the access token and related endpoint URI's.
    /// - Parameters:
    ///   - accessToken: The access token generated by the authorization server.
    ///   - refreshUri: The location of the endpoint to refresh the OAuth token for the authenticator.
    ///   - transactionUri: The location of the endpoint to perform transaction validation.
    ///   - authenticatorId: An identifier generated during registration to uniquely identify the authenticator.
    ///   - certificateTrust: A delegate to handle session-level certificate pinning.
    public init(with accessToken: String, refreshUri: URL, transactionUri: URL, authenticatorId: String, certificateTrust: URLSessionDelegate? = nil) {
        self.accessToken = accessToken
        self.refreshUri = refreshUri
        self.transactionUri = transactionUri
        self.authenticatorId = authenticatorId
        
        if let certificateTrust = certificateTrust {
            // Set the URLSession for certificate pinning.
            self.urlSession = URLSession(configuration: .default, delegate: certificateTrust, delegateQueue: nil)
        }
        else {
            self.urlSession = URLSession.shared
        }
    }
    
    /// Refresh the OAuth token associated with the registered authenticator.
    ///
    /// When the `transactionID` is supplied, information relating to that transaction identifier is returned while in a PENDING state.  Otherwise the next transaction is returned.
    /// ```swift
    /// // Using the authenticator properties, create a new CloudAuthenticatorService.
    /// let service = CloudAuthenticatorService(with: authenticator.token.accessToken, refreshUri: authenticator.refreshUri, transactionUri: authenticator.transactionUri)
    ///
    /// // Invoke the refreshToken(autnticator.token.refreshToken) method, optional is the accountName and pushToken.
    /// let result = try await service.refreshToken(using: "abc123")
    /// print(result)
    ///
    /// // Update authenticator token.
    /// authenticator.token = result
    ///
    /// // Encode and save the authenticator to JSON file.
    /// let encoder = JSONEncoder()
    /// encoder.outputFormatting = .prettyPrinted
    /// 
    /// let data = try encoder.encode(authenticator)
    /// print(String(data: data, encoding: .utf8)!)
    /// data.write(to: "authenticator.json")
    /// ```
    ///
    /// - Parameters:
    ///   - refreshToken: The refresh token of the existing authenticator registration.
    ///   - accountName: A list of values added to the initiation request.
    ///   - pushToken: A token that identifies the device to Apple Push Notification Service (APNS).
    ///   - additionalData: (Optional) A collection of options associated with the service.
    /// - Returns: A new `TokenInfo` for the authenticator.
    ///
    /// Communicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.  Refer to [Registering Your App with APNs](https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns).
    public func refreshToken(using refreshToken: String, accountName: String? = nil, pushToken: String? = nil, additionalData: [String: Any]? = nil) async throws -> TokenInfo {
        var attributes = MFAAttributeInfo.dictionary()
        attributes.removeValue(forKey: "applicationName")
        
        if let accountName = accountName {
            attributes["accountName"] = accountName
        }
        
        if let pushToken = pushToken {
            attributes["pushToken"] = pushToken
        }
        
        let data: [String: Any] = [
            "refreshToken": refreshToken,
            "attributes": attributes
        ]
        
        // Convert body dictionary to Data.
        guard let body = try? JSONSerialization.data(withJSONObject: data, options: []) else {
            throw MFAServiceError.serializationFailed
        }
        
        // Construct the request to decode and return the token.
        let resource = HTTPResource<TokenInfo>(json: .post, url: refreshUri, body: body)
        
        // Perfom the request.
        let result = try await self.urlSession.dataTask(for: resource)
        
        // Update the internal accessToken and return
        self.accessToken = result.accessToken
        
        return result
    }
    
    /// Retrieve the next transaction that is associated with an authenticator registration.
    ///
    /// When a `transactionID` is supplied, information relating to that transaction identifier is returned while in a PENDING state.  Otherwise the next transaction is returned.
    /// ```swift
    /// // Using the authenticator properties, create a new CloudAuthenticatorService.
    /// let service = CloudAuthenticatorService(with: authenticator.token.accessToken, refreshUri: authenticator.refreshUri, transactionUri: authenticator.transactionUri)
    ///
    /// // Invoke the nextTransaction() method, optional is the transacionID.
    /// let result = try await service.nextTransaction()
    /// print(result)
    /// ```
    ///
    /// - Parameters:
    ///   - transactionID: The transaction verification identifier.
    public func nextTransaction(with transactionID: String? = nil) async throws -> NextTransactionInfo {
        // Update the transactionUri with a query parameter to filter the response.
        var transactionUri = URL(string: "\(self.transactionUri.absoluteString)\(TransactionFilter.nextPending.rawValue)")!
        
        if let transactionID = transactionID {
            let allowedCharacterSet = CharacterSet(charactersIn: "\"").inverted
            let queryString = String(format: "\(TransactionFilter.pendingByIdentifier.rawValue)", transactionID)
            transactionUri = URL(string: "\(self.transactionUri.absoluteString)/\(queryString.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet)!)")!
        }
        
        // Create the request headers.
        let headers = ["Authorization": "Bearer \(self.accessToken)"]
        let resource = HTTPResource<NextTransactionInfo>(.get, url: transactionUri, accept: .json, headers: headers, parse: parsePendingTransaction)
        
        // Perfom the request.
        let result = try await self.urlSession.dataTask(for: resource)
        self.currentPendingTransaction = result.current
        
        return result
    }
    
    public func completeTransaction(action userAction: UserAction = .verify, signedData: String) async throws {
        guard let pendingTransaction = currentPendingTransaction else {
            throw MFAServiceError.invalidPendingTransaction
        }
        
        defer {
            // Clear the current pending transaction
            self.currentPendingTransaction = nil
        }
        
        // Create the request parameters.
        var data: [[String: Any]] = [[:]]
        
        // Only verify operations where we pass the signedData.
        if userAction == .verify {
            data = [["id": pendingTransaction.factorID.uuidString.lowercased(), "userAction": userAction.rawValue, "signedData": signedData]]
        }
        else {
            data = [["id": pendingTransaction.factorID.uuidString.lowercased(), "userAction": userAction.rawValue]]
        }
        
        // Covert body dictionary to Data.
        guard let body = try? JSONSerialization.data(withJSONObject: data, options: []) else {
            throw MFAServiceError.serializationFailed
        }
         
        // Create the request headers.
        let headers = ["Authorization": "Bearer \(self.accessToken)"]
        let resource = HTTPResource<Void>(.post, url: pendingTransaction.postbackUri, accept: .json, contentType: .json, body: body, headers: headers)
        
        // Perfom the request.
        return try await self.urlSession.dataTask(for: resource)
    }
}

extension CloudAuthenticatorService {
    // MARK: Internal transaction structures
    
    /// Describes the result of acquiring a pending transction from cloud instances.
    internal struct TransactionResult: Decodable {
        var count: Int = 0
        var verifications: [VerificationInfo]?

        /// The root level JSON structure for decoding.
        private enum CodingKeys: String, CodingKey {
            case total
            case verifications
        }

        struct VerificationInfo: Decodable {
            let id: String
            let creationTime: Date
            let transactionInfo: String
            let methodInfo: [MethodInfo]

            /// The nested root decoding structure based off `CodingKeys`.  Used for cloud transaction data and method parsing.
            private enum CodingKeys: String, CodingKey {
                case id
                case creationTime
                case transactionInfo = "transactionData"
                case methodInfo = "authenticationMethods"
            }
        }

        struct MethodInfo: Decodable {
            let id: String
            let methodType: String
            let subType: String
        }

        // MARK: Initializers

        /// Creates a new instance by decoding from the given decoder.
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: Decoder) throws {
            // Root keys
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            count = try rootContainer.decode(Int.self, forKey: .total)
            verifications = try rootContainer.decode([VerificationInfo].self, forKey: .verifications)
        }
    }
}

extension CloudAuthenticatorService {
    /// Parse the pending transaction for a cloud authenticator.
    ///
    /// - Parameters:
    ///   - data: The data returned by the server.
    ///   - response: An object that provides response metadata, such as HTTP headers and status code.
    /// - Returns: A value that represents either a success or a failure, including an associated value in each case.
    private func parsePendingTransaction(data: Data?, response: URLResponse?) -> Result<NextTransactionInfo, Error> {
        guard let data = data, !data.isEmpty else {
            return Result.failure(MFAServiceError.invalidDataResponse)
        }
        
        // Parse the transaction data.
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(DateFormatter.iso8061FormatterBehavior)
        
        guard let result = try? decoder.decode(TransactionResult.self, from: data) else {
            return Result.failure(MFAServiceError.decodingFailed)
        }

        // Check if there are no verification, return a nil.
        if result.count == 0 {
            return Result.success(NextTransactionInfo(current: nil, countOfPendingTransactions: result.count))
        }

        // Create the pending transaction.
        guard let pendingTransaction = createPendingTransaction(using: result) else {
            return Result.failure(MFAServiceError.unableToCreateTransaction)
        }

        return Result.success(NextTransactionInfo(pendingTransaction, result.count))
    }
    
    /// Creates a `PendingTransaction` based on the parsed transaction and attribute data.
    /// - parameter result: The `CloudTransactionResult` containing the parsed data.
    /// - parameter transactionId: The identifier of the transaction.
    /// - remark: The `CloudTransactionResult.verifications` have been sorted by `creationDate`.
    private func createPendingTransaction(using result: TransactionResult) -> PendingTransactionInfo? {
        // 1. Get the first transaction.
        guard let verificationInfo = result.verifications?.first else {
            return nil
        }

        // 2. Get the postback to the transaction.
        let postbackUri = self.transactionUri.appendingPathComponent(verificationInfo.id)

        // 3. Get the message to display.
        let message = transactionMessage(using: verificationInfo.transactionInfo)

        // 4. Construct the factor that is used to lookup the private key from the Keychain.
        guard let methodInfo = verificationInfo.methodInfo.first else {
            return nil
        }

        // 4. Construct the transaction context information into additional data.
        let additionalData = createAdditionalData(using: verificationInfo.transactionInfo)

        // 5. Construct the pending transaction taking data from the transaction, attribute and authentication info.
        let result = PendingTransactionInfo(id: verificationInfo.id,
                                            message: message,
                                            postbackUri: postbackUri,
                                            factorID: UUID(uuidString: methodInfo.id) ?? UUID(),
                                            factorType: methodInfo.subType,
                                            dataToSign: verificationInfo.transactionInfo,
                                            timeStamp: verificationInfo.creationTime,
                                            additionalData: additionalData)

        return result
    }

    /// Creates a dictionary of available transaction data from the `CloudTransactionResult`.
    /// - parameter json: A JSON string representing the transaction data `VerificationInfo`.
    /// - returns: An array of `TransactionAttribute` and corresponding value.
    private func createAdditionalData(using json: String) -> [TransactionAttribute: String] {
        var result: [TransactionAttribute: String] = [:]

        // Convert the String into Data and serialize to JSON object.
        let value = json.data(using: .utf8)!
        guard var data = try? JSONSerialization.jsonObject(with: value, options: []) as? [String: Any] else {
            return result
        }
        
        // Add the IP address to the result, then remove from dictionary.
        if let ipAddress = data["originIpAddress"] as? String {
            result.updateValue(ipAddress, forKey: .ipAddress)
            data.removeValue(forKey: "originIpAddress")
        }

        // Add the user-agent to the result, then remove from dictionary.
        if let userAgent = data["originUserAgent"] as? String {
            result.updateValue(userAgent, forKey: .userAgent)
            data.removeValue(forKey: "originUserAgent")
        }

        // Add the default type (of request) to the result.  Might be overriden if specified in additionalData.
        result.updateValue(NSLocalizedString("PendingRequestTypeDefault", bundle: Bundle.module, comment: ""), forKey: .type)

        // Assign the remaining values to TransactionAttribute.custom
        if var additionalData = data["additionalData"] as? [[String: String]] {
            additionalData.forEach { item in
                // Add the type to the result, then remove from dictionary.
                if item["name"] == "type", let index = additionalData.firstIndex(where: { $0["name"] == "type" }), let type = item["value"] {
                    result.updateValue(type, forKey: .type)
                    additionalData.remove(at: index)
                }

                // Add the location to the result, then remove from dictionary.
                if item["name"] == "originLocation", let index = additionalData.firstIndex(where: { $0["name"] == "originLocation" }), let location = item["value"] {
                    result.updateValue(location, forKey: .location)
                    additionalData.remove(at: index)
                }

                // Add the image to the result, then remove from dictionary.
                if item["name"] == "imageURL", let index = additionalData.firstIndex(where: { $0["name"] == "imageURL" }), let imageUrl = item["value"] {
                    result.updateValue(imageUrl, forKey: .image)
                    additionalData.remove(at: index)
                }
            }

            // Assign the remaining values to TransactionAttribute.custom
            if !additionalData.isEmpty {
                let customData = try! JSONSerialization.data(withJSONObject: additionalData)
                let customJson = String(data: customData, encoding: .utf8)!
                result.updateValue(customJson, forKey: .custom)
            }
        }

        return result
    }

    /// Gets the message associated with the transaction data from the `TransactionResult`.
    /// - parameter json: A JSON string representing the transaction data `VerificationInfo`.
    /// - returns: The transaction message or the default pending transaction message.
    private func transactionMessage(using value: String) -> String {
        let data = value.data(using: .utf8)!
        
        guard let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] else {
            return NSLocalizedString("PendingRequestMessageDefault", bundle: Bundle.module, comment: "")
        }
        
        guard let message = json["message"] as? String else {
            return NSLocalizedString("PendingRequestMessageDefault", bundle: Bundle.module, comment: "")
        }

        return message
    }
}
