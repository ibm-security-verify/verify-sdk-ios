//
// Copyright contributors to the IBM Security Verify MFA SDK for iOS project
//

import Foundation
import Core
import Authentication

// MARK: Protocols

/// An inerface that defines a multi-factor authentication service operations.
public protocol MFAServiceDescriptor: Actor {
    /// The access token generated by the authorization server.
    var accessToken: String { get }
    
    /// The location of the endpoint to refresh the OAuth token for the authenticator.
    var refreshUri: URL { get }

    /// The location of the endpoint to perform transaction validation.
    var transactionUri: URL { get }
    
    /// The current pending transaction.
    var currentPendingTransaction: PendingTransactionInfo? { get }
    
    /// Refresh the OAuth token associated with the registered authenticator.
    /// - Parameters:
    ///   - refreshToken: The refresh token of the existing authenticator registration.
    ///   - accountName: The account name associated with the service.
    ///   - pushToken: A token that identifies the device to Apple Push Notification Service (APNS).
    ///   - additionalData: (Optional) A collection of options associated with the service.
    /// - Returns: A new `TokenInfo` for the authenticator.
    ///
    /// Communicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.  Refer to [Registering Your App with APNs](https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns).
    func refreshToken(using refreshToken: String, accountName: String?, pushToken: String?, additionalData: [String: Any]?) async throws -> TokenInfo
    
    /// Retrieve the next transaction that is associated with an authenticator registration.
    ///
    /// When a `transactionID` is supplied, information relating to that transaction identifier is returned while in a PENDING state.  Otherwise the next transaction is returned.
    /// - Parameters:
    ///   - transactionID: The transaction verification identifier.
    /// - Returns: The ``NextTransactionInfo`` representing the transaction and the number of pending transactions associated with the authenticator.
    func nextTransaction(with transactionID: String?) async throws -> NextTransactionInfo
    
    /// Complete a second factor authentication challenge associated with a registered authenticator.
    /// - Parameters:
    ///   - userAction: The enumerated type of user actions that can be performed to complete a transaction.
    ///   - signedData: The base64 encoded value using the private key associated with the factor enrollment.
    func completeTransaction(action userAction: UserAction, signedData: String) async throws
}

extension MFAServiceDescriptor {
    /// Performs a password-less authentication operation.
    /// - Parameters:
    ///   - loginUri: The endpoint that performs the passwordless login.  The URL is provided as `qrlogin_endpoint` in the response data returned from a QR scan.
    ///   - code: The authorization code provided in the QR scan.
    public func login(using loginUri: URL, code: String) async throws {
        let body = """
        {"lsi":"\(code)"}
        """.data(using: .utf8)!
        
        // Create the request headers.
        let headers = ["Authorization": "Bearer \(self.accessToken)"]
        let resource = HTTPResource<Void>(.post, url: loginUri, accept: .json, contentType: .json, body: body, headers: headers)
        
        // Perfom the request
        return try await URLSession.shared.dataTask(for: resource)
    }
    
    /// Complete a second factor authentication challenge associated with a registered authenticator.
    /// - Parameters:
    ///   - userAction: The enumerated type of user actions that can be performed to complete a transaction.
    ///   - factor: The enrolled factor associated with transaction.
    ///
    /// ```swift
    /// let controller = MFAServiceController(using: authenticator)
    /// let service =  controller.initiate()
    /// let nextTranaction = try await service.nextTranaction()
    ///
    /// // Get the transaction information and the enrolled factor type to use for signing.
    /// do {
    ///   if let transaction = nextTranaction.current, let factorType = authenticator.allowedFactors.first(where: { $0.id == transaction.factorID }) {
    ///     try await service.completeTransaction(action .verify, factor: factorType)
    ///   }
    /// }
    /// catch let error {
    ///   print(error)
    /// }
    /// ```
    public func completeTransaction(action userAction: UserAction = .verify, factor: FactorType) async throws {
        guard let pendingTransaction = currentPendingTransaction else {
            throw MFAServiceError.invalidPendingTransaction
        }
        
        guard let value = factorNameAndAlgorithm(for: factor) else {
            throw MFAServiceError.general(message: "Invalid factor to perform signing.")
        }
        
        var signedData = ""
        
        if userAction == .verify {
            // Get the private from the Keychain for the factor.
            signedData = try sign(name: value.name, algorithm: value.algorithm.rawValue, dataToSign: pendingTransaction.dataToSign)
        }
        
        try await completeTransaction(action: userAction, signedData: signedData)
    }
}

// MARK: Alias

/// A tuple containing the pending transaction information and a count of the number of transactions still pending.
public typealias NextTransactionInfo = (current: PendingTransactionInfo?, countOfPendingTransactions: Int)

// MARK: Enums

/// The enumerated type of user actions that can be performed to complete a transaction.
public enum UserAction: String {
    /// The user has denied or rejected the transaction.
    case deny = "USER_DENIED"

    /// The user has denied the transaction and marked it as fraudulent.
    case markAsFraud = "USER_FRAUDULENT"

    /// The user is attempting to verify the transaction. The request must also include a value for `signedData`.
    case verify = "VERIFY_ATTEMPT"

    /// The user was unable toverify the transaction due to a failed device biometry attempt.
    case failedBiometry = "BIOMETRY_FAILED"
}

public enum MFAServiceError: Error, LocalizedError, Equatable {
    /// The signing hash algorithm was invalid.
    case invalidSigningHash
    
    /// No pending transaction was available to complete.
    case invalidPendingTransaction
    
    /// Serialization conversion failed.
    case serializationFailed
    
    /// The response data was invalid.
    case invalidDataResponse
    
    /// The JSON decoding operation failed.
    case decodingFailed
    
    /// Unable to create the pending transaction.
    case unableToCreateTransaction
    
    /// General error with custom message.
    case general(message: String)
}


/// An instance you use to instaniate an ``MFAServiceDescriptor`` to perform transaction, login and token refresh operations.
public class MFAServiceController {
    /// The multi-factor authenticator.
    private let authenticator: any MFAAuthenticatorDescriptor
    
    /// Creates the instance with an ``MFAServiceDescriptor``.
    /// - Parameters:
    ///   - authenticator: The multi-factor authenticator.
    public required init(using authenticator: some MFAAuthenticatorDescriptor) {
        precondition(authenticator is OnPremiseAuthenticator || authenticator is CloudAuthenticator)
        self.authenticator = authenticator
    }
    
    /// Determines the service to initiate for a multi-factor authenticator.
    public func initiate() -> MFAServiceDescriptor {
        var certificateTrust: URLSessionDelegate? = nil
        
        // Attempt to create the pinned certificate.
        if let publicKeyCertificate = authenticator.publicKeyCertificate, let pinnedCertificate = PinnedCertificateDelegate(with: publicKeyCertificate) {
            certificateTrust = pinnedCertificate
        }
        
        if let authenticator = authenticator as? OnPremiseAuthenticator {
            // If we created a certificate trust, then ignore the self-signed flag.
            if certificateTrust == nil && authenticator.ignoreSSLCertificate {
                certificateTrust = SelfSignedCertificateDelegate()
            }
            
            return OnPremiseAuthenticatorService(with: self.authenticator.token.accessToken,
                                                 refreshUri: self.authenticator.refreshUri,
                                                 transactionUri: self.authenticator.transactionUri,
                                                 clientId: authenticator.clientId,
                                                 authenticatorId: self.authenticator.id,
                                                 certificateTrust: certificateTrust)
        }
        
        return CloudAuthenticatorService(with: self.authenticator.token.accessToken,
                                         refreshUri: self.authenticator.refreshUri,
                                         transactionUri: self.authenticator.transactionUri,
                                         authenticatorId: self.authenticator.id,
                                         certificateTrust: certificateTrust)
    }
}
